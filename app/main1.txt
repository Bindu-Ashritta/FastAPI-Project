from fastapi import FastAPI, Depends, HTTPException
from fastapi.templating import Jinja2Templates
from starlette.requests import Request
from starlette.responses import RedirectResponse
from starlette.middleware.sessions import SessionMiddleware
from authlib.integrations.starlette_client import OAuth, OAuthError
from .config import CLIENT_ID, CLIENT_SECRET, DATABASE_URL
from fastapi.staticfiles import StaticFiles
from sqlalchemy.orm import Session
from .database import get_db
from . import crud
from fastapi.security import OAuth2PasswordBearer
import google.auth
from google.auth.transport.requests import Request as GoogleRequest
from sqlalchemy import create_engine
from . import models
import logging

app = FastAPI()

# OAuth2 bearer token for authentication
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# Middleware setup with the generated secret key
app.add_middleware(SessionMiddleware, secret_key="603add864d0e236a8a79c9d54fe336f60e8b47cb06b5c6c0924290fd706f5677")
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# OAuth setup with Google
oauth = OAuth()
oauth.register(
    name='google',
    server_metadata_url='https://accounts.google.com/.well-known/openid-configuration',
    client_id=CLIENT_ID,
    client_secret=CLIENT_SECRET,
    client_kwargs={'scope': 'email openid profile', 'redirect_uri': 'http://localhost:8000/auth'}
)

engine = create_engine(DATABASE_URL)
models.Base.metadata.create_all(bind=engine)

logging.basicConfig(level=logging.DEBUG)

def verify_token_and_get_user_info(token: str):
    try:
        # Example using authlib and Google OAuth
        credentials = oauth.google.parse_id_token(token)
        if credentials:
            return credentials
        else:
            raise HTTPException(status_code=401, detail="Invalid token")
    except Exception as e:
        raise HTTPException(status_code=401, detail="Invalid token")


def get_user_from_token(db: Session, token: str):
    user_info = verify_token_and_get_user_info(token)
    # You can then query your DB based on user_info['email'] or other identifier
    user = crud.get_user_by_email(db, user_info['email'])
    return user


# Route Definitions

@app.get("/")
def index(request: Request):
    user = request.session.get('user')
    if user:
        return RedirectResponse('welcome')
    return templates.TemplateResponse("home.html", {"request": request})


@app.get('/welcome')
def welcome(request: Request):
    user = request.session.get('user')
    if not user:
        return RedirectResponse('/')
    return templates.TemplateResponse('welcome.html', {'request': request, 'user': user})


@app.get("/login")
async def login(request: Request):
    url = request.url_for('auth')
    logging.debug(f"Redirecting to: {url}")
    return await oauth.google.authorize_redirect(request, url)


@app.get('/auth')
async def auth(request: Request):
    try:
        token = await oauth.google.authorize_access_token(request)
        logging.debug(f"Received token: {token}")
    except OAuthError as e:
        logging.error(f"OAuthError: {e.error}")
        return templates.TemplateResponse('error.html', {'request': request, 'error': e.error})
    user = token.get('userinfo')
    if user:
        request.session['user'] = dict(user)
    return RedirectResponse('welcome')


@app.get('/logout')
def logout(request: Request):
    request.session.pop('user', None)
    return RedirectResponse('/')



@app.post("/watchlist/")
def create_watchlist(symbol: str, list_name: str, db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)):
    user = get_user_from_token(db, token)
    if user:
        return crud.create_watchlist(db, user.id, symbol, list_name)
    raise HTTPException(status_code=401, detail="Not authenticated")


@app.get("/watchlist/{id}")
def get_watchlist_entry(id: int, db: Session = Depends(get_db)):
    watchlist_entry = crud.get_watchlist_by_id(db, id)
    if watchlist_entry:
        return watchlist_entry
    raise HTTPException(status_code=404, detail="Watchlist entry not found")